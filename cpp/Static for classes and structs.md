# Ключевое слово static в классах и структурах

Если ключевое слово static используется с переменной, это означает, что во всех экземплярах класса будет только один экземпляр этой переменной. 

Если один экземпляр класса изменит значение статической переменной, это отразится во всех остальных экземплярах класса, потому что есть только одна переменная, несмотря на количество экземпляров. Это что-то вроде глобальной переменной. 

Со статическими методами мы получаем аналогичный эффект, у нас нет доступа к экземпляру класса 

Внутри статического метода мы не можем написать код, который ссылается на экземпляр класса, поскольку у нас нет ссылки этого экземпляра класса. 

Напишем простую структуру, которая хранит две переменные и выводит их на экран 

```cpp
struct Entity
{
    int x, y;

    void Print()
    {
        std::cout << "x: " << x << " y: " << y << std::endl;
    }
};
```

Создадим экземпляр сущности и инициализируем поля структуры стандартным способом
```cpp
Entity e1;
e1.x = 2;
e1.y = 3;
```

Создадим второй экземпляр и инициализируем поля структуры с помощью инициализатора
```cpp
Entity e2{ 5, 8 };
```

Распечатаем значения в консоль
```cpp
e1.Print();
e2.Print();
```

Вот такой вывод мы получим
```
x: 2 y: 3
x: 5 y: 8
```

Однако, всё  изменится, когда мы сделаем переменные статическими
```cpp
struct Entity
{
    static int x, y;

    void Print()
    {
        std::cout << "x: " << x << " y: " << y << std::endl;
    }
};

```
Во-первых, мы получим ошибку E0146 при использовании инцииализатора, потому что переменные x, y больше не являются членами структуры. 
```cpp
Entity e2{ 5, 8 }; // E0146
```

Давайте исправим это
```cpp
Entity e2;
e2.x = 5;
e2.y = 8;
```

Во-вторых, при попытке запустить код мы получим ошибки LNK2001 и LNK1120, потому что мы не определили эти переменные
```
LNK2001	неразрешенный внешний символ "public: static int Entity::x" (?x@Entity@@2HA).
LNK2001	неразрешенный внешний символ "public: static int Entity::y" (?y@Entity@@2HA).
Ошибка	LNK1120	неразрешенных внешних элементов: 2
```

Мы можем определить их ниже 
```cpp
struct Entity
{
    static int x, y;

    void Print()
    {
        std::cout << "x: " << x << " y: " << y << std::endl;
    }
};

int Entity::x;
int Entity::y;
```

Если мы запустим код теперь, то получим вот такой результат
```
x: 5 y: 8
x: 5 y: 8
```

Вывод одинаковый, потому что переменные обоих сущностей ссылаются на одну и ту же область в памяти. И поэтому нам нет смысла обращаться к ним вот так
```cpp
Entity e2;
e2.x = 5;
e2.y = 8;
```

Если мы исправим код, то наглядно увидим, что фактически обращаемся к одним и тем же переменной
```cpp
Entity e1;
Entity::x = 2;
Entity::y = 3;

Entity e2;
Entity::x = 5;
Entity::y = 8;
``` 

Мы также можем сделать статическим метод структуры, тогда нам не нужны экземпляры классов
```cpp
static void Print()
{
    std::cout << "x: " << x << " y: " << y << std::endl;
}

Entity::x = 2;
Entity::y = 3;

Entity::x = 5;
Entity::y = 8;

Entity::Print();
```

Предположим, что мы хотим иметь статический метод и обычные нестатические публичные переменные
```cpp
int x, y;

// E0245
static void Print()
{
    std::cout << "x: " << x << " y: " << y << std::endl;
}
```

Мы получим ошибку E0245, потому что статический метод не имеет экземпляра класса. 

В обычном случае, нестатический метод класса всегда получает экземпляр текущего класса в качестве параметра. Что-то вроде этого
```cpp
void Print(Entity e) // Скрытый параметр
{
    std::cout << "x: " << e.x << " y: " << e.y << std::endl;
}
```

Статический метод это тоже самое, как если бы мы написали метод вне класса.
```cpp
struct Entity
{
    int x, y;
};

void Print() // Ошибка
{
    std::cout << "x: " << x << " y: " << y << std::endl;
}
```